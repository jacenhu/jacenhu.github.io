(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{435:function(v,_,t){"use strict";t.r(_);var r=t(10),s=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"《剑指offer》小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#《剑指offer》小结"}},[v._v("#")]),v._v(" 《剑指offer》小结")]),v._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("p",[v._v("《剑指offer》这本书适合校招练习算法和数据结构，也可以作为工作后的算法与数据结构巩固练习。")]),v._v(" "),_("p",[v._v("另外，附上LeetCode上剑指offer（第二版）的在线刷题链接，可在阅读完练习使用：")]),v._v(" "),_("p",[v._v("https://leetcode-cn.com/problemset/lcof/")]),v._v(" "),_("h2",{attrs:{id:"正文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[v._v("#")]),v._v(" 正文")]),v._v(" "),_("p",[v._v("这本书的前沿部分已经总结了全书的内容。一共50个算法题，并对这些算法题进行了思路讲解。")]),v._v(" "),_("h3",{attrs:{id:"版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#版本"}},[v._v("#")]),v._v(" 版本")]),v._v(" "),_("p",[v._v("2012年。")]),v._v(" "),_("h3",{attrs:{id:"主要内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主要内容"}},[v._v("#")]),v._v(" 主要内容")]),v._v(" "),_("p",[_("strong",[v._v("第 1 章")]),v._v("介绍流程。")]),v._v(" "),_("p",[_("strong",[v._v("第 2 章")]),v._v("梳理基础知识。")]),v._v(" "),_("p",[v._v("第 3 章讨论写出高质量代码的 3 个要点。从规范性、完整性和鲁棒性 3 个方面提高代码的质量。")]),v._v(" "),_("p",[_("strong",[v._v("第 4 章")]),v._v("总结解决难题的常用思路。用画图、举例和分解复杂问题 3 种思路来解决问题。")]),v._v(" "),_("p",[_("strong",[v._v("第 5 章")]),v._v("介绍如何优化代码的时间效率和空间效率。学会优化时间效率及空间换时间的常用算法。")]),v._v(" "),_("p",[_("strong",[v._v("第 6 章")]),v._v("总结各项能力。学习能力和沟通能力、知识迁移能力、抽象建模能力和发散思维能力。")]),v._v(" "),_("p",[_("strong",[v._v("第 7 章")]),v._v("是两个案例。")]),v._v(" "),_("h3",{attrs:{id:"详细"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#详细"}},[v._v("#")]),v._v(" 详细")]),v._v(" "),_("p",[_("strong",[v._v("题4替换空格")]),v._v("。测试用例需包含正常情况和异常情况，且考虑时间复杂度。")]),v._v(" "),_("p",[_("strong",[v._v("题5从尾到头打印链表")]),v._v("。后进先出，使用栈。")]),v._v(" "),_("p",[_("strong",[v._v("题6重建二叉树")]),v._v("。前序遍历第一个数字为根节点，中序遍历找到根节点位置，从而确定左右子树，再递归解决。")]),v._v(" "),_("p",[_("strong",[v._v("题8旋转数组的最小数字")]),v._v("。二分法。")]),v._v(" "),_("p",[_("strong",[v._v("题9斐波那契数列")]),v._v("。递归➕循环。")]),v._v(" "),_("p",[_("strong",[v._v("题11数值的整数次方")]),v._v("。需考虑底数为0而指数为负数的处理。")]),v._v(" "),_("p",[_("strong",[v._v("题12打印1到最大的n位数")]),v._v("。大数问题，用字符串模拟加法并打印。")]),v._v(" "),_("p",[_("strong",[v._v("题13在O(1)时间删除链表节点")]),v._v("。创新；用下一个节点的内容对比被删除的节点，然后把下一个节点删除。")]),v._v(" "),_("p",[_("strong",[v._v("题14调整属于顺序使偶数位于奇数之前")]),v._v("。双指针。")]),v._v(" "),_("p",[_("strong",[v._v("题15链表中倒数第k个节点")]),v._v("。双指针遍历。")]),v._v(" "),_("p",[_("strong",[v._v("题17合并2个排序的链表")]),v._v("。递归。")]),v._v(" "),_("p",[_("strong",[v._v("题18树的子结构")]),v._v("。递归。")]),v._v(" "),_("p",[_("strong",[v._v("题19二叉树的镜像")]),v._v("。先序遍历树，递归。")]),v._v(" "),_("p",[_("strong",[v._v("题21包含min函数的栈")]),v._v("。借用辅助栈保存最小元素。")]),v._v(" "),_("p",[_("strong",[v._v("题22栈的压入、弹出序列")]),v._v("。举例分析，辅助栈。")]),v._v(" "),_("p",[_("strong",[v._v("题23从上往下打印二叉树")]),v._v("。队列。")]),v._v(" "),_("p",[_("strong",[v._v("题24二叉搜索树的后序遍历序列")]),v._v("。找出后序遍历的规律。")]),v._v(" "),_("p",[_("strong",[v._v("题25二叉树中和为某一值的路径")]),v._v("。栈。")]),v._v(" "),_("p",[_("strong",[v._v("题26复杂链表的复制")]),v._v("。用O(n)的空间消耗把时间复杂度由O(N^2)降低到O(n)。")]),v._v(" "),_("p",[_("strong",[v._v("题28字符串的排列")]),v._v("。递归。")]),v._v(" "),_("p",[_("strong",[v._v("题30最小的k个数")]),v._v("。最大堆。")]),v._v(" "),_("p",[_("strong",[v._v("题31连续子数组的最大和")]),v._v("。动态规划。")]),v._v(" "),_("p",[_("strong",[v._v("题35第一个只出现一次的字符")]),v._v("。哈希表。")]),v._v(" "),_("p",[_("strong",[v._v("题37两个链表的第一个公共节点")]),v._v("。辅助栈。")]),v._v(" "),_("p",[_("strong",[v._v("题38数字在排序数组中出现的次数")]),v._v("。二分查找、递归。")]),v._v(" "),_("p",[_("strong",[v._v("题39二叉树的深度")]),v._v("。递归。")]),v._v(" "),_("p",[_("strong",[v._v("题46求1+2+……+n")]),v._v("。发散思维。")])])}),[],!1,null,null,null);_.default=s.exports}}]);